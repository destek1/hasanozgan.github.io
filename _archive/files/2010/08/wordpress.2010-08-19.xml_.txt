<?xml version="1.0" encoding="UTF-8"?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your blog. -->
<!-- It contains information about your blog's posts, comments, and categories. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your blog. -->

<!-- To import this information into a WordPress blog follow these steps. -->
<!-- 1. Log in to that blog as an administrator. -->
<!-- 2. Go to Tools: Import in the blog's admin panels (or Manage: Import in older versions of WordPress). -->
<!-- 3. Choose "WordPress" from the list. -->
<!-- 4. Upload this file using the form provided on that page. -->
<!-- 5. You will first be asked to map the authors in this export file to users -->
<!--    on the blog.  For each author, you may choose to map to an -->
<!--    existing user on the blog or to create a new user -->
<!-- 6. WordPress will then import each of the posts, comments, and categories -->
<!--    contained in this file into your blog -->

<!-- generator="WordPress/3.0" created="2010-08-19 17:39"-->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.0/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.0/"
>

<channel>
	<title>phpArchitect</title>
	<link>http://phparchitect.org/tr</link>
	<description>Web Patterns &#38; Practices</description>
	<pubDate>Sat, 10 Apr 2010 18:36:56 +0000</pubDate>
	<generator>http://wordpress.org/?v=3.0</generator>
	<language>en</language>
	<wp:wxr_version>1.0</wp:wxr_version>
	<wp:base_site_url>http://phparchitect.org/tr</wp:base_site_url>
	<wp:base_blog_url>http://phparchitect.org/tr</wp:base_blog_url>
		<wp:category><wp:category_nicename>araclar</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Araçlar]]></wp:cat_name><wp:category_description><![CDATA[PHP ile ilgili araçların tanıtıldığı kategoridir.]]></wp:category_description></wp:category>
		<wp:category><wp:category_nicename>genel</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Genel]]></wp:cat_name></wp:category>
		<wp:category><wp:category_nicename>hayatin-icinden</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Hayatın İçinden]]></wp:cat_name><wp:category_description><![CDATA[PHP ile ilgili gerçek hayattan yaşananların anlatıldığı kategori. (cURL örneği gibi)]]></wp:category_description></wp:category>
		<wp:category><wp:category_nicename>incelemeler</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[İncelemeler]]></wp:cat_name><wp:category_description><![CDATA[Yeni çıkan teknoloji, protkol ve apilerin incelenmesini amaçlayan kategoridir.]]></wp:category_description></wp:category>
		<wp:category><wp:category_nicename>senaryolar</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Senaryolar]]></wp:cat_name><wp:category_description><![CDATA[Senaryolar, problem örnekleri ve incelemeleri üzerinedir. Örneğin Mail gönderim altyapısı, Dynamic subbdomain vb.]]></wp:category_description></wp:category>
		<wp:category><wp:category_nicename>tasarim-sablonlari</wp:category_nicename><wp:category_parent></wp:category_parent><wp:cat_name><![CDATA[Tasarım Şablonları]]></wp:cat_name><wp:category_description><![CDATA[Design Patterns ve AntiPatterns vb konuları inceler.]]></wp:category_description></wp:category>
			<wp:tag><wp:tag_slug>nix</wp:tag_slug><wp:tag_name><![CDATA[*nix]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>activemongo</wp:tag_slug><wp:tag_name><![CDATA[activemongo]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>cron</wp:tag_slug><wp:tag_name><![CDATA[cron]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>daemon</wp:tag_slug><wp:tag_name><![CDATA[daemon]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>geoloacation</wp:tag_slug><wp:tag_name><![CDATA[geoloacation]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>geolocation</wp:tag_slug><wp:tag_name><![CDATA[geolocation]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>html5</wp:tag_slug><wp:tag_name><![CDATA[html5]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>ip2location</wp:tag_slug><wp:tag_name><![CDATA[ip2location]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>kohana</wp:tag_slug><wp:tag_name><![CDATA[kohana]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>latitude</wp:tag_slug><wp:tag_name><![CDATA[latitude]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>linux</wp:tag_slug><wp:tag_name><![CDATA[linux]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>longitude</wp:tag_slug><wp:tag_name><![CDATA[longitude]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>mango</wp:tag_slug><wp:tag_name><![CDATA[mango]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>mongodb</wp:tag_slug><wp:tag_name><![CDATA[mongodb]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>morph</wp:tag_slug><wp:tag_name><![CDATA[morph]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>mysql</wp:tag_slug><wp:tag_name><![CDATA[mysql]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>nosql</wp:tag_slug><wp:tag_name><![CDATA[nosql]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>pear</wp:tag_slug><wp:tag_name><![CDATA[pear]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>php</wp:tag_slug><wp:tag_name><![CDATA[php]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>radius</wp:tag_slug><wp:tag_name><![CDATA[radius]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>search</wp:tag_slug><wp:tag_name><![CDATA[search]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>symfony</wp:tag_slug><wp:tag_name><![CDATA[symfony]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>system</wp:tag_slug><wp:tag_name><![CDATA[system]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>ubuntu</wp:tag_slug><wp:tag_name><![CDATA[ubuntu]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>unix</wp:tag_slug><wp:tag_name><![CDATA[unix]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>zend</wp:tag_slug><wp:tag_name><![CDATA[zend]]></wp:tag_name></wp:tag>
		<wp:tag><wp:tag_slug>zipcode</wp:tag_slug><wp:tag_name><![CDATA[zipcode]]></wp:tag_name></wp:tag>
		
	<generator>http://wordpress.org/?v=3.0</generator>

		<item>
		<title>Hakkında</title>
		<link></link>
		<pubDate>Sun, 31 Jan 2010 12:04:30 +0000</pubDate>
		<dc:creator><![CDATA[admin]]></dc:creator>
		
		<category><![CDATA[Genel]]></category>

		<category domain="category" nicename="genel"><![CDATA[Genel]]></category>

		<guid isPermaLink="false">http://www.phparchitect.org/tr/?page_id=2</guid>
		<description></description>
		<content:encoded><![CDATA[Bu blog, <a href="http://hasanozgan.com">Hasan Ozgan</a>'ın PHP ile Web mimarileri ve pratikleri hakkında yazılarını içerir. Yazar, Web'in ölçeklenebilirlik, tasarım kalıpları ve diğer konuları hakkında vakit buldukça kaliteli içerik üretmeyi, hayattın içinden örnekler ve vakalar hakkında yazılar ve teknoloji incelemeleri yapmayı hedeflemektedir. 

]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>2</wp:post_id>
		<wp:post_date>2010-01-31 12:04:30</wp:post_date>
		<wp:post_date_gmt>2010-01-31 12:04:30</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>about</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>page</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
								<wp:postmeta>
		<wp:meta_key>_edit_lock</wp:meta_key>
		<wp:meta_value><![CDATA[1270575198]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_edit_last</wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_wp_page_template</wp:meta_key>
		<wp:meta_value><![CDATA[default]]></wp:meta_value>
		</wp:postmeta>
							</item>
		<item>
		<title>Şeytan, Pengueni Dürterse</title>
		<link></link>
		<pubDate>Sun, 28 Mar 2010 15:28:57 +0000</pubDate>
		<dc:creator><![CDATA[HasanOzgan]]></dc:creator>
		
		<category domain="tag"><![CDATA[*nix]]></category>

		<category domain="tag" nicename="nix"><![CDATA[*nix]]></category>

		<category><![CDATA[Araçlar]]></category>

		<category domain="category" nicename="araclar"><![CDATA[Araçlar]]></category>

		<category domain="tag"><![CDATA[cron]]></category>

		<category domain="tag" nicename="cron"><![CDATA[cron]]></category>

		<category domain="tag"><![CDATA[daemon]]></category>

		<category domain="tag" nicename="daemon"><![CDATA[daemon]]></category>

		<category domain="tag"><![CDATA[linux]]></category>

		<category domain="tag" nicename="linux"><![CDATA[linux]]></category>

		<category domain="tag"><![CDATA[pear]]></category>

		<category domain="tag" nicename="pear"><![CDATA[pear]]></category>

		<category domain="tag"><![CDATA[php]]></category>

		<category domain="tag" nicename="php"><![CDATA[php]]></category>

		<category domain="tag"><![CDATA[system]]></category>

		<category domain="tag" nicename="system"><![CDATA[system]]></category>

		<category domain="tag"><![CDATA[unix]]></category>

		<category domain="tag" nicename="unix"><![CDATA[unix]]></category>

		<guid isPermaLink="false">http://www.phparchitect.org/tr/?p=18</guid>
		<description></description>
		<content:encoded><![CDATA[<p>Günümüzde birçok site arkada yapılacak görevleri çalıştırmak için görev yöneticileri kullanılır. Crontab (Zaman ayarlı) ve Daemon (kendi halinde çalışan) iki görev yöneticinin arasındaki bence tek fark (durum bu kadar basit olmasada) Crontab'ın 1 dakikanın altındaki süreçlere göre çalışmamasıdır. Bu görevler için Daemon denilen ve <strong>/etc/init.d</strong> altında tetiklenen ve sinyallerle çalıştırılıp durdurulabilen ve process id değeri üreten bir teknolojiye ihtiyaç duymasıdır. Daemon'lar init.d altında bir çalıştırıcı scripte sahip olmaya bilir ama durdumak istendiğinde güç kullanılarak öldürülmesi (kill)  gerekir ki, kritik işlerde bu pek tehlikeli bir yöntemdir. Init.d altındaki başlatma scripti bir proses(PID) dosya yaratır ve daemon'u çalıştırır. Sonrasında durdumak isterse daemon'a sinyal gönderir. Böylece uygulama durma sinyalini görünce düzgün bir şekilde sonlanır. Crontab ise belli bir işin bellir bir saatte yapılmasını sağlar. Saatte bir, her 15 dk.'da bir ayın 5. günü, her çarşamba saat 15'te gibi...</p>
<!--more-->
<p>Kullanım alanlarına birkaç örnek vermek gerekirse; </p>
<p> <strong>Daemon</strong>;  Özellikle kuyruktaki işleri işlemek için çok kullanılır.</p>
<ul>
	<li>Video converter</li>
	<li>Email/SMS gönderme</li>
	<li>RSS ayrıştırma.</li>
</ul>
<strong>Cron;</strong>
<ul>
	<li>Günde bir kez gönderilecek işler. Örneğin; doğum günü epostaları.</li>
	<li>Ayda hatta yılda bir kez yapılacak işler. Anneler gününde temanın otomatik olarak değiştirilmesi.</li>
	<li>Haftanın belli bir günü yapılacak olan işler. Her Pazartesi indirim puanı oluşturup, rastgele 500 üyeye gönderme.</li>
	<li>Saatte bir yapılacak işler, Site için RSS oluşturma.</li>
</ul>
Daemon yazmak genelde C dili ile yazılan işlerdendir. Çünkü bu iş hem performans hem de sistem programlama(sinyaller ve prosesler) bilgisi  gerekir. Buna rağmen, işin mantığı ise  PHP, ve benzeri web dillerinde yazılmıştır. Belki de biraz bu sebeplerle Crontab ile görev tanımı yapılır. Crontab kullanmak güzeldir ama kurulum sürecinde ek yük getirir. Bunların doğru bir şekilde çalıştığının kaydının tutulması (<strong>loging</strong>) ve gözlenmesi (<strong>monitoring</strong>) işlerinin yapılmasıda cabası. 

<p> Bu yazı <a title="Chronical Task Management Tool" href="http://code.google.com/p/chronical/" target="_blank"><strong>Chronical</strong></a> projesinin bilgi tasarımının ilk taslaklarını içermesinin yanında aktif olan mevcut uygulamalardan örnekler de verilecektir.</p>

<p><i><strong>Peki bu işleri ne şekilde yapımak gerekir?</strong></i></p> 
<p><strong>1) System_Daemon PEAR Paketi</strong></p>
<p> <a href="http://pear.php.net/" target="_blank">PEAR</a> kütüphanesi içerisinde bulunan ve <a href="http://kevin.vanzonneveld.net/">Kevin van Zonneveld</a> tarafından geliştirilen <a href="http://pear.php.net/package/System_Daemon" target="_blank">System_Daemon</a> paketi kolayca linux daemonları yaratmanıza olanak verecek olan harika bir araçtır. Becerileri;
<ol>
	<li>İşletim sistemine özel başlangıç ayarlarının ve kurulumlarının kolayca yapılabilmesi.</li>
	<li>İşlem kaydı (loging) tutalbilmesi. Ve PEAR kütüphanesi ile uyumluluk</li>
	<li>Kullanım kolaylığı, birazdan örnek uygulamada da görebileceksiniz</li>
	<li>Sinyallerle çalışma ve özelleştirme</li>
</ol>
<strong>System Daemon Kurulum;</strong>

Linux sunucunuzda PEAR kurulu ise şu şekilde;
<pre lang="bash">$ pear install -f System_Daemon
</pre>
Yada <a href="http://download.pear.php.net/package/System_Daemon-0.10.2.tgz" target="pear">şuradan</a> indirerek kullanabilirsiniz.

<strong>Kullanım;</strong>

<strong>job/sms_sender.php</strong> isimli bir php dosyası yaratalım.
<pre lang="php">// Gerekli olan Daemon kütüphanesi.
// Bu kütüphane include_dir dizininin gösterdiği bir yerde olmalı.
require_once "System/Daemon.php";                 

// İzin verilen parametreler
$runmode = Array (
    // tek başına çalışması için
    'standalone' => false,
    // initd dizininde çalıştırma betiği yaratır.
    'write-initd' => false,
);

// Scan command line attributes for allowed arguments
foreach ($argv as $k=&gt;$arg) {
    if (substr($arg, 0, 2) == '--' && isset($runmode[substr($arg, 2)])) {
        $runmode[substr($arg, 2)] = true;
    }
}

// appName minimum gerekli olan parametredir.
System_Daemon::setOption("appName", "sms_sender");

// System_Daemon::setOption ile tek tek  ya da
// System_Daemon::setOptions($options) ile toplu olarak girilebilir.

$options = array(
    //'appName' => 'sms_sender',
    'appDir' => dirname(__FILE__),
    'appDescription' => 'MT SMS Sender',
    'authorName' => 'Hasan Ozgan',
    'authorEmail' => 'hasan@ozgan.net',
    'sysMaxExecutionTime' => '0',
    'sysMaxInputTime' => '0',
    'sysMemoryLimit' => '1024M',
    'appRunAsGID' => 1000,
    'appRunAsUID' => 1000,
);
System_Daemon::setOptions($options);

// Eger daemon olarak çalışmayacaksa
// System_Daemon::start() methodu ile başlatılabilir.
if ($runmode["standalone"]) {
    System_Daemon::start();
}

// job --write-initd parametresi ile çalıştırıldığında kendini kaydeder.
// açılışta çalıştırıldığında ise --init.d parametresi alır.
if (!$runmode["write-initd"]) {
     System_Daemon::info('not writing an init.d script this time');
} else {
    if (($initd_location = System_Daemon::writeAutoRun()) === false) {
        System_Daemon::notice('unable to write init.d script');
    } else {
        // parametreli log örneği...
        System_Daemon::info(
            'sucessfully written startup script: %s',
            $initd_location
        );
    }
}

// Daemon stop sinyali gelene kadar çalışmaya devam eder.
while (!System_Daemon::isDying()) {
   // Buraya işinizle ilgili kodları eklemelisiniz.

   $messages = OutgoingSMS::fetchMessages();
   foreach ($messages as $message) {
       if (!$message->send()) {
            System_Daemon::error("Message not send");
       }
   }

   // Daemonlarda önemli olan sonsuz döngüde bir miktar 
   // işlem yapıp sistemi dinlendirmek gerekir.
   // Bunun için ise iterate methodu ile saniye cinsinden 
   // bir süre vererek çağrı yapmak gerekir.
   System_Daemon::iterate(5);
}

System_Daemon::stop();
</pre>

<p>
Yazdığımız scripti tek başına çalıştırmak için ise;
<pre lang="bash">
$ job/send_sms --standalone
</pre>
yazmamız yeterlidir. Service birkez çalışıp sonlanacaktır.
</p>

<p>
Servisimizi init.d altına kaydetmek için ise; 
<pre lang="bash">
$ sudo job/send_sms --write-initd
</pre>
yazmamız yeterlidir. Eğer burada hata alırsanız, init.d dizinin yazma haklarını kontrol etmeniz gerekir.
<pre lang="bash">
$ sudo chmod a+w /etc/init.d
</pre>
</p>

Bu işlemleri yaptıktan sonra <strong>appName</strong> parametresinde girdiğimiz isme göre;
<ul>
<li>/etc/init.d/send_sms</li>
<li>/var/log/send_sms.log</li>
<li>/var/run/send_sms/send_sms.pid</li>
</ul>
dosyaları oluşturulur. 
İşletim sisteminin açılışta servisi çalıştırması için kayıt etmek gerekir.
<pre lang="bash">
# kayıt için
$ sudo update-rc.d send_sms defaults
# kaldırmak için ise 
$ sudo update-rc.d -f send_sms remove
</pre>

<p><strong>2) Periodic Kütüphanesi</strong></p>
<p><strong>Arbit</strong> firması tarafından geliştirilen <a href="http://arbitracker.org/periodic.html">Periodic</a> kütüphanesini kullanabilirsiniz. Bu kütüphane crontab işlerini kendi sarmalayan biraz daha karmaşık bir mimariye sahiptir. 
</p>
<pre lang="xml">
<?xml version="1.0"?> 
 <task>
  <config>
     <reScheduleTime>92384032</reScheduleTime>
     <timeout>92384032</timeout>  
  </config> 
  <command type="shell">
     <!-- ... -->
  </command>
  <command type="vcsWrapperUpdate">
     <!-- ... -->
  </command>
  <!-- ... -->
</task>
</pre>
<p>
Periodic ile ilgili daha detaylı bilgiyi <a href="http://arbitracker.org/periodic/design.html">şuradan</a> alabilirsiniz.
</p>
<p><strong>3) Chronical Job Management Projesi</strong</p>
<p>
Bu proje benim yapacağım hem cron hem de daemon desteği ile melez çalışacak bir projedir. Henüz fikir halindedir. Projene adresine <a href="http://chronical.googlecode.com">şuradan</a> ulaşılabilir. 
</p>
<p>
Bu proje servis işlerinizi hızlı ve kolay bir şekilde merkezi bir yerden yönetmeniz, durumunu kontrol etmenizi amaçlar.
</p>
<p><strong>Özellikleri</strong>
<ul>
   <li>Yaml ile kolayca güncellenebilen ayar dosyası</li>
   <li>Daemon kaydetme, kaldırmak ve durum bilgisi almak için kullanılacak çalıştırılabilir betik</li>
   <li>İş mantığınızı barındıran kodları çalıştıracak Abstract sınıf.</li>
</li>
</ul>
</p>
<p>
<strong>Örnek proje ayar dosyası (task.config);</strong>
<pre lang="yaml">
# Period Format
# second minute hour day month dayOfWeek weekOfMonth
# second: 0-59
# minute: 0-59
# hour: 0-23
# day: 1-31
# month: 1-12
# dayOfWeek: 1-7
# weekOfMonth: 1-5 

# proje adina göre tek bir daemon oluşur. 
# Bu daemon işlerin tamamını alt prosesler yaratarak yönetir.

proje_adi:
    gorev_adi:
        class: Application_Jobs_SmsSender
        # her 30 saniyede bir çalış anlamında.
        period: */30 * * * * * 
    change_theme:
        class: Application_Jobs_ChangeTheme
        # Mayıs ayının ikinci pazar günü saat gece 2'de 
        # Anneler gününde çalış.
        period: * 2 * 5 7 2
</pre>
</p>
<p><strong>Arayüz Sınıfı</strong></p>
<pre lang="php">
interface Chronical_Job_Interface 
{
     // Ayar dosyasına verilen sınıfların bu 
     // arayüzden gerçekleştirilmesi gerekir.
     public function run();
}
</pre>

<p><strong>Örnek Sınıfı</strong></p>
<pre lang="php">
class Application_Jobs_SendSms 
                    extends Joy_Application 
                    implements Chronical_Job_Interface
{
     public function run()
     {
           // TODO: Yapılacak işler....
     }
}
</pre>

<p><strong>Örnek log ayar dosyası;</strong> Bu dosya chronical uygulamasının log ve pid ayarları ile ilgili bir dosyadır.  Ubuntu ve debian temelli dağıtımlar için <strong>/etc/chronical.ini</strong>
</p>
<pre lang="ini">
[folders]
     folder.log = /var/log/
     fodler.pid = /var/run/
     folder.init.d = /etc/init.d
[defaults]
; seconds
     default.sleep_time = 5
</pre>
<p><strong>Düşünülen betik dosyası örnek işler</strong></p>
<pre lang="bash">
# OS startup install for init.d
$ chronical install task.config

# OS startup uninstall for init.d
$ chronical uninstall task.config

# Görev çalıştırma 
$ chronical start proje_adi:gorev_adi

# Görev durdurma
$ chronical start proje_adi:gorev_adi

# Görev durumunu görme
$ chronical status proje_adi:gorev_adi
</pre>

Kısaca Unix sistemleri üzerinde daemon ve crontab işleri bu şekilde. (:
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>18</wp:post_id>
		<wp:post_date>2010-03-28 15:28:57</wp:post_date>
		<wp:post_date_gmt>2010-03-28 15:28:57</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>seytan-pengueni-durterse</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
								<wp:postmeta>
		<wp:meta_key>_edit_lock</wp:meta_key>
		<wp:meta_value><![CDATA[1270610078]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_edit_last</wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
								<wp:comment>
		<wp:comment_id>5</wp:comment_id>
		<wp:comment_author><![CDATA[HasanOzgan]]></wp:comment_author>
		<wp:comment_author_email>hasanozgan@gmail.com</wp:comment_author_email>
		<wp:comment_author_url>http://hasanozgan.com</wp:comment_author_url>
		<wp:comment_author_IP>85.105.19.190</wp:comment_author_IP>
		<wp:comment_date>2010-03-28 18:09:28</wp:comment_date>
		<wp:comment_date_gmt>2010-03-28 18:09:28</wp:comment_date_gmt>
		<wp:comment_content><![CDATA[Teşekkür ederim Onur, düzelttim.]]></wp:comment_content>
		<wp:comment_approved>1</wp:comment_approved>
		<wp:comment_type></wp:comment_type>
		<wp:comment_parent>4</wp:comment_parent>
		<wp:comment_user_id>2</wp:comment_user_id>
		</wp:comment>
				<wp:comment>
		<wp:comment_id>6</wp:comment_id>
		<wp:comment_author><![CDATA[Halid]]></wp:comment_author>
		<wp:comment_author_email>halid@halid.org</wp:comment_author_email>
		<wp:comment_author_url>http://halid.org</wp:comment_author_url>
		<wp:comment_author_IP>78.188.29.18</wp:comment_author_IP>
		<wp:comment_date>2010-03-29 15:34:31</wp:comment_date>
		<wp:comment_date_gmt>2010-03-29 15:34:31</wp:comment_date_gmt>
		<wp:comment_content><![CDATA[Makale için teşekkürler.

Ancak cron'u saniyelik bile çalıştırabilmek mümkün.

http://blog.halid.org/halidsaidaltuner/linux-unix/saniyelik-cron-eklemek-ve-varsayilan-crontab-editorunu-degistirmek/]]></wp:comment_content>
		<wp:comment_approved>1</wp:comment_approved>
		<wp:comment_type></wp:comment_type>
		<wp:comment_parent>0</wp:comment_parent>
		<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
				<wp:comment>
		<wp:comment_id>7</wp:comment_id>
		<wp:comment_author><![CDATA[HasanOzgan]]></wp:comment_author>
		<wp:comment_author_email>hasanozgan@gmail.com</wp:comment_author_email>
		<wp:comment_author_url>http://hasanozgan.com</wp:comment_author_url>
		<wp:comment_author_IP>85.105.19.190</wp:comment_author_IP>
		<wp:comment_date>2010-03-29 17:33:36</wp:comment_date>
		<wp:comment_date_gmt>2010-03-29 17:33:36</wp:comment_date_gmt>
		<wp:comment_content><![CDATA[Halid Cron hacking yapmışsınız. :) Konuya katkın için teşekkür ederim. Lakin Cron ile bu tür bir işlem yapmanın riski şu; uygulamayı güvenli olarak sonlandırdığından emin olamayabilirsin.]]></wp:comment_content>
		<wp:comment_approved>1</wp:comment_approved>
		<wp:comment_type></wp:comment_type>
		<wp:comment_parent>6</wp:comment_parent>
		<wp:comment_user_id>2</wp:comment_user_id>
		</wp:comment>
				<wp:comment>
		<wp:comment_id>4</wp:comment_id>
		<wp:comment_author><![CDATA[Onur YALAZI]]></wp:comment_author>
		<wp:comment_author_email>onur@yalazi.org</wp:comment_author_email>
		<wp:comment_author_url>http://www.yalazi.org</wp:comment_author_url>
		<wp:comment_author_IP>88.234.170.214</wp:comment_author_IP>
		<wp:comment_date>2010-03-28 17:20:00</wp:comment_date>
		<wp:comment_date_gmt>2010-03-28 17:20:00</wp:comment_date_gmt>
		<wp:comment_content><![CDATA[job/sms_sender.php de 5inci satırda $rubmode  yazılmış sanırım $runmode olması gerekiyor.]]></wp:comment_content>
		<wp:comment_approved>1</wp:comment_approved>
		<wp:comment_type></wp:comment_type>
		<wp:comment_parent>0</wp:comment_parent>
		<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
			</item>
		<item>
		<title>PHP ve NoSQL (MongoDB)</title>
		<link></link>
		<pubDate>Tue, 06 Apr 2010 17:14:48 +0000</pubDate>
		<dc:creator><![CDATA[HasanOzgan]]></dc:creator>
		
		<category domain="tag"><![CDATA[activemongo]]></category>

		<category domain="tag" nicename="activemongo"><![CDATA[activemongo]]></category>

		<category><![CDATA[Araçlar]]></category>

		<category domain="category" nicename="araclar"><![CDATA[Araçlar]]></category>

		<category><![CDATA[İncelemeler]]></category>

		<category domain="category" nicename="incelemeler"><![CDATA[İncelemeler]]></category>

		<category domain="tag"><![CDATA[kohana]]></category>

		<category domain="tag" nicename="kohana"><![CDATA[kohana]]></category>

		<category domain="tag"><![CDATA[linux]]></category>

		<category domain="tag" nicename="linux"><![CDATA[linux]]></category>

		<category domain="tag"><![CDATA[mango]]></category>

		<category domain="tag" nicename="mango"><![CDATA[mango]]></category>

		<category domain="tag"><![CDATA[mongodb]]></category>

		<category domain="tag" nicename="mongodb"><![CDATA[mongodb]]></category>

		<category domain="tag"><![CDATA[morph]]></category>

		<category domain="tag" nicename="morph"><![CDATA[morph]]></category>

		<category domain="tag"><![CDATA[nosql]]></category>

		<category domain="tag" nicename="nosql"><![CDATA[nosql]]></category>

		<category domain="tag"><![CDATA[php]]></category>

		<category domain="tag" nicename="php"><![CDATA[php]]></category>

		<category domain="tag"><![CDATA[symfony]]></category>

		<category domain="tag" nicename="symfony"><![CDATA[symfony]]></category>

		<category domain="tag"><![CDATA[ubuntu]]></category>

		<category domain="tag" nicename="ubuntu"><![CDATA[ubuntu]]></category>

		<category domain="tag"><![CDATA[zend]]></category>

		<category domain="tag" nicename="zend"><![CDATA[zend]]></category>

		<guid isPermaLink="false">http://www.phparchitect.org/tr/?p=92</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>NoSQL Nedir? </strong>
NoSQL, ilişkisel olmayan bir veritabanıdır. SQL dili kullanmadan Map-Reduce kavramı ile sorgulama yapılır. Map ve Reduce, aslında fonksiyonel programlamada sıkça kullanılan iki fonksiyondur. Excel buna güzel bir örnektir.

Gün geçmiyorki tarih tekerrür etmesin. NoSQL kelimesini birkaç blogta okuduğum vakit Yazılım Mimarı olan 40-45 yaşlarında bir büyüğüme bundan söz ettim. O da, aslında bunun yıllar önce kullanılan Berkley_DB'den başka birşey olmadığını söyledi. Berkley_DB aynı anda çalışan binlerce iş parçacığının(thread) 256 terabyte büyüklüğüde bir veritabanına erişebilmesini mümkün kılar. SQLite'ta BerkleyDB'ye benzer bir yapıya sahiptir. Ama biz SQLite'ı küçük işlerde kullanırız!. Biraz kafa karıştırıcı olduğunu biliyorum. Burada ilginç bir döngü var? Internet mozaik bir yapıdadır. Ve dağınıktır. Bu dağınık yapıyı Google'ın yaptığı gibi indekslemek (tabiri caizse tüm interneti indirmek isterseniz), dünyanın en büyük ve en iyi ilişkilsel veritabanını kanalize olmuş Oracle bile yetersiz kalacaktır.

<strong>Peki neden?</strong>
<ol>
	<li> İlişkisel veritabanları, yazma hakkı olan bir sunucu üzerinde koşar. Ana sunucuya birşey olması durumunda slave makinelerden biri master'a çevirilir ve yola devam edilir. Burada ki veritabanına gelen yazma isteklerini düşünebiliyor musunuz?</li>
	<li> Veritabanı büyüdüğünde yedekleme gibi işlemler (bakım) sorun olmaya başlar.</li>
	<li> Replikasyona dair sorunlar yaşayabilirsiniz.</li>
	<li> Google'ın 1 milyon makinesi olduğu varsayılıyor! Bu kadar makinelerin yarısının aynı anda tek bir makineye yazma isteği bulunduğunu düşünürsek durum daha net anlaşılabilir.</li>
</ol>
Google, startup döneminde, bir mühendislik şirketi gibi davrandı ve ihtiyaçlarını iyi analiz etti. 10.000$'lık sunucular almak yerine 500$'lık ucuz makineler satın aldı. Ve bu makinelerin kısa ömürlü ve her an patlayacağını bilerek kodlarını yazdı. Ve BigTable denilen (Hadoop bunun açık kaynak halidir) Map ve Reduce fonksiyonları ile sorgulamayı sağlayan bir mimari kurdu. Bu mimarinin en önemli özelliği; makinelerden biri göçse bile, sistemin çalışmaya devam etmesidir. Her kaydın 3-5 ayrı sunucuda kopyası bulunmaktadır. Bu şekilde web için en uygun devasa bir Mosaic oluşturdular.

Peki NoSQL konusuna giriş yaptık. Fakat bu seferde karşımıza birden fazla NoSQL türü çıkacak;
<ol>
	<li> Key/Value database (Redis, MemcachedDB vb..)</li>
	<li> Document Oriented database. (MongoDB, CouchDB)</li>
	<li> Object database (db4o)</li>
	<li> Graph databse (neo4j)</li>
	<li> Tabular (bigtable, hadoop)</li>
</ol>
Biz bu türlerden, belge yönelimli veritabanları konusu üzerinede duracağız. Belge yönelimli veritabanları, nesne yönelimli ve ilişkisel veritabanlarının alt katmanıdır. Yukarıda saydığım veritabanlarının birbirinden farkını ve merak ettiğiniz diğer konuları <a href="http://en.wikipedia.org/wiki/NoSQL">Vikipedi</a>'den okuyabilirsiniz. MongoDB'yi neden tercih ettiğime dair bilgilerine ise; <a href="http://www.mongodb.org/display/DOCS/Benchmarks">benchmark</a> testlerinden ve <a href="http://www.mongodb.org/display/DOCS/Comparing+Mongo+DB+and+Couch+DB">kıyaslama tablosundan</a> edinebilirsiniz.<!--more-->

<strong>MongoDB'yi Denemek İçin;</strong>
Eğer yukarıdaki bilgiler sizi tatmin etmedi ve MongoDB'yi biraz kurcalamak istiyorsanız ve zamanım yok makineye kurmadan denemek istiyorum diyorsanız; online olarak <a href="http://try.mongodb.org">şuradan</a> deneyebilmeniz mümkün.

<strong>MongoDB sunucusunun çalıştırmak için;</strong>
<pre lang="bash">mongod --dbpath=/data/mongo
</pre>
<strong>MongoDB'nin Ubuntu'ya Kurulumu</strong>
MongoDB'nin Ubuntuya nasıl kurulduğunu anlatacak olsamda diğer işletim sistemleri ve linux dağıtımlarına nasıl kurulacağını <a href="http://www.mongodb.org/display/DOCS/Quickstart">şuradan</a> öğrenebilirsiniz.
APTITUDE ile kurmak için; aşağıdaki dağıtımınız için uygun olan paket kaynak adresini seçerek <strong>/etc/apt/sources.list</strong> dosyasına kopyalamanız yeterlidir.
<pre lang="bash"># for Ubuntu Lucid (10.4) (built using a prerelease installation)
deb http://downloads.mongodb.org/distros/ubuntu 10.4 10gen

# for Ubuntu Karmic (9.10)
deb http://downloads.mongodb.org/distros/ubuntu 9.10 10gen

# for Ubuntu Jaunty (9.4)
deb http://downloads.mongodb.org/distros/ubuntu 9.4 10gen</pre>
ve sonrasında da aşağıdaki komutları çalıştırmanız yeterlidir.
<pre lang="bash">sudo aptitude update
sudo aptitude install mongodb-stable
# ya da
sudo aptitude install mongodb-unstable
# ya da
sudo aptitude install mongodb-snapshot</pre>
<pre lang="bash"># install dependicies for Ubuntu 9.04 ve 9.10
sudo apt-get -y install tcsh git-core scons g++
sudo apt-get -y install libpcre++-dev
                      libboost-dev libreadline-dev
                      xulrunner-1.9.1-dev

# get source
git clone git://github.com/mongodb/mongo.git
# build
scons
# install
sudo scons --prefix=/opt/mongo install</pre>
Görüldüğü üzere kurulum son derece basit. Derlenerek kurulum işleminde yapılması gereken başlangıç betiği hazırlamak.
<pre lang="ruby">#!/usr/bin/env ruby -w
# mongo ;; 2010 (cc) Jan Riethmayer
# This work is licensend under a Creative Commons Attribution 3.0 license.

require 'optparse'
options = {}

optparse = OptionParser.new do|opts|
  opts.banner = &lt;&lt;-BANNER
Usage: sudo ./mongo [options]
BANNER

  options[:dbpath] = "/data/mongodb/"
  opts.on( '-d', '--dbpath', 'Select DB path. Defaults to /data/mongodb/' ) do |path|
    options[:dbpath] = path
  end

  options[:port] = "27017"
  opts.on( '-p', '--port PORT', 'Listening to port 27017 by default' ) do |port|
    options[:port] = port
  end

  options[:fork] = false
  opts.on( '-f', '--fork', 'Run as daemon' ) do
    options[:fork] = true
  end

  options[:logpath] = "/var/log/mongodb.log"
  opts.on( '-l', '--logfile FILE', 'Defaults to /var/log/mongodb.log' ) do |file|
    options[:logpath] = file
  end

  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
end

# Parse the command-line. Remember there are two forms
# of the parse method. The 'parse' method simply parses
# ARGV, while the 'parse!' method parses ARGV and removes
# any options found there, as well as any parameters for
# the options.
optparse.parse!

class Go
  attr_accessor :opts

  def initialize(opts)
    @opts = opts
  end

  def start
    puts "Starting on port #{@opts[:port]} with dbpath #{@opts[:dbpath]}"
    puts "Running as Daemon" if @opts[:fork]
    puts "Writing to logpath /var/log/mongodb.log"
    path = "--dbpath #{@opts[:dbpath]}"
    port = "--port #{@opts[:port]}"
    log = "--logpath #{@opts[:logpath]} --logappend"
    fork = "#{@opts[:fork] ? '--fork' : ''}"
    params = [path, port, log, fork].join(" ")
    result = %x{ ./mongodb/bin/mongod #{ params } }
    puts result
  end

  def stop
    process = %x{ ps -o pid,command ax | grep mongod }
    found = false
    matcher = process.scan(/(\d+).+?bin.+?mongod.+?--fork/) do |pid|
      found = true
      puts "Killing process #{pid}"
      %x{ kill -2 #{pid} }
    end
    puts "No mongod process found" unless found
  end
end

go = Go.new(options)

case ARGV[0]
  when /start/ : go.start
  when /stop/ : go.stop
  else
  raise ArgumentError.new("mongo (start|stop) or mongo -h for help.")
end</pre>
Yukarıdaki dosyayı <strong>/etc/init.d/mongo</strong> şeklinde kaydetmek gerekiyor.

<strong>PHP Kurulumu</strong>
<pre lang="bash">sudo pecl install mongo
</pre>
PHP için monog eklentisinin hatasız bir şekilde derlenebilmesi için bilgisayarınızda <strong>phpize</strong> yüklü olmalıdır. Derleme işleminden sonra, php.ini dosyanıza;
<pre lang="ini">extension=mongo.so
</pre>
ekledikten sonra kurulum işlemi tamamlanmış olur.

Artık PHP mongo ile konuşabilecek durumda. PHP'nin sınıfları ile ilgi detaylı bilgiye <a href="http://tr.php.net/mongo">php.net/mongo</a> adresinden ulaşabilirsiniz.

PHPMyAdmin gibi bir yönetim arabirimi arıyorsanız, <a href="http://www.phpmoadmin.com/">PHPMoAdmin</a> tam size göre.

<strong>PHP Frameworkleri</strong>
Birçok popüler PHP framework'ünün MongoDB için ActiveRecord patternine uygun yazılmış eklentisi mevcut. Gelin bunlara bir göz atalım;
<strong>Zend Framework</strong>
<ul>
	<li><a href="http://framework.zend.com/wiki/display/ZFPROP/Zend_Nosql_Mongo+-+Valentin+Golev">Zend_Nosql_Mongo</a> Zend firması tarafından geliştirilen sınıf.</li>
	<li><a href="http://github.com/coen-hyde/Shanty-Mongo">Shanty Mongo</a> ise diğer bir sınıf.</li>
</ul>
<strong>CakePHP</strong>
<a href="http://github.com/ichikaway/mongoDB-Datasource/downloads">MongoDB Datasource</a> sınıfı.

<strong>Kohana</strong>
<a href="http://github.com/Wouterrr/mangodb">Mango</a> ise Kohana için ActiveRecord paternini kullanan bir sınıf.

<strong>Symfony</strong>
Symfony için Jason Mooberry tarafından yazılan makalenin, <a href="http://blog.jasonmooberry.com/2009/08/mongodb-and-symfony-yes-part-1-inserts/">1. bölümü</a> ve <a href="http://blog.jasonmooberry.com/2009/08/mongodb-and-symfony-yes-part-2-simple-queries/">2. bölümünden</a> bilgi edinebilirsiniz.

<strong>Kütüphaneler</strong>
<ul>
	<li><a href="http://github.com/crodas/ActiveMongo">ActiveMongo</a> güzel bir kütüphane. Bu kütüphaneye başlangıç yapmak için ise <a href="http://crodas.org/activemongo.php">şu makaleye</a> bakabilirsiniz.</li>
	<li><a href="http://code.google.com/p/mongodb-morph/">Morph Kütüphanesi</a></li>
</ul>
<strong>PHP ile İlgili Diğer Makaleler</strong>
<ul>
	<li><a href="http://technosophos.com/content/mongodb-5-things-every-php-developer-should-know-about-mongodb">http://technosophos.com/content/mongodb-5-things-every-php-developer-should-know-about-mongodb</a></li>
	<li><a href="http://www.businessinsider.com/how-we-use-mongodb-2009-11">
http://www.businessinsider.com/how-we-use-mongodb-2009-11</a></li>
	<li><a href="http://www.lafermeduweb.net/billet/nosql-mongodb-et-php-premiere-approche-781.html">http://www.lafermeduweb.net/billet/nosql-mongodb-et-php-premiere-approche-781.html</a></li>
	<li><a href="http://blog.boxedice.com/2009/07/25/choosing-a-non-relational-database-why-we-migrated-from-mysql-to-mongodb">http://blog.boxedice.com/2009/07/25/choosing-a-non-relational-database-why-we-migrated-from-mysql-to-mongodb</a></li>
	<li><a href="http://www.phpclasses.org/blog/post/118-Developing-scalable-PHP-applications-using-MongoDB.html">http://www.phpclasses.org/blog/post/118-Developing-scalable-PHP-applications-using-MongoDB.html</a></li>
</ul>
MongoDB gerçekten çok iyi belgelenmiş ve birçok web çatısı tarafından desteklenen harika bir araç. Bu konuda ki paylaşımlarınızı bekliyorum. :)]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>92</wp:post_id>
		<wp:post_date>2010-04-06 17:14:48</wp:post_date>
		<wp:post_date_gmt>2010-04-06 17:14:48</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>php-ve-nosql-mongodb</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
								<wp:postmeta>
		<wp:meta_key>_edit_lock</wp:meta_key>
		<wp:meta_value><![CDATA[1270610088]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_edit_last</wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_oembed_ead9a72fc961f237b3994be6bb251750</wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_oembed_1ff83bdbbf3147a069f4f011933cfe2c</wp:meta_key>
		<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
								<wp:comment>
		<wp:comment_id>11</wp:comment_id>
		<wp:comment_author><![CDATA[Osman]]></wp:comment_author>
		<wp:comment_author_email>osman.guven@gmail.com</wp:comment_author_email>
		<wp:comment_author_url></wp:comment_author_url>
		<wp:comment_author_IP>78.188.23.24</wp:comment_author_IP>
		<wp:comment_date>2010-07-14 14:21:03</wp:comment_date>
		<wp:comment_date_gmt>2010-07-14 14:21:03</wp:comment_date_gmt>
		<wp:comment_content><![CDATA[Script/Main.py", line 858, in _main şeklinde hata aldım, mongodb başka bahara :)]]></wp:comment_content>
		<wp:comment_approved>0</wp:comment_approved>
		<wp:comment_type></wp:comment_type>
		<wp:comment_parent>0</wp:comment_parent>
		<wp:comment_user_id>0</wp:comment_user_id>
		</wp:comment>
			</item>
		<item>
		<title>Lokasyon Bazlı Servisler Yaratmak</title>
		<link></link>
		<pubDate>Sat, 10 Apr 2010 18:35:07 +0000</pubDate>
		<dc:creator><![CDATA[HasanOzgan]]></dc:creator>
		
		<category domain="tag"><![CDATA[geolocation]]></category>

		<category domain="tag" nicename="geolocation"><![CDATA[geolocation]]></category>

		<category><![CDATA[Hayatın İçinden]]></category>

		<category domain="category" nicename="hayatin-icinden"><![CDATA[Hayatın İçinden]]></category>

		<category domain="tag"><![CDATA[html5]]></category>

		<category domain="tag" nicename="html5"><![CDATA[html5]]></category>

		<category><![CDATA[İncelemeler]]></category>

		<category domain="category" nicename="incelemeler"><![CDATA[İncelemeler]]></category>

		<category domain="tag"><![CDATA[ip2location]]></category>

		<category domain="tag" nicename="ip2location"><![CDATA[ip2location]]></category>

		<category domain="tag"><![CDATA[latitude]]></category>

		<category domain="tag" nicename="latitude"><![CDATA[latitude]]></category>

		<category domain="tag"><![CDATA[longitude]]></category>

		<category domain="tag" nicename="longitude"><![CDATA[longitude]]></category>

		<category domain="tag"><![CDATA[mysql]]></category>

		<category domain="tag" nicename="mysql"><![CDATA[mysql]]></category>

		<category domain="tag"><![CDATA[php]]></category>

		<category domain="tag" nicename="php"><![CDATA[php]]></category>

		<category domain="tag"><![CDATA[radius]]></category>

		<category domain="tag" nicename="radius"><![CDATA[radius]]></category>

		<category domain="tag"><![CDATA[search]]></category>

		<category domain="tag" nicename="search"><![CDATA[search]]></category>

		<category><![CDATA[Senaryolar]]></category>

		<category domain="category" nicename="senaryolar"><![CDATA[Senaryolar]]></category>

		<category domain="tag"><![CDATA[zipcode]]></category>

		<category domain="tag" nicename="zipcode"><![CDATA[zipcode]]></category>

		<guid isPermaLink="false">http://www.phparchitect.org/tr/?p=113</guid>
		<description></description>
		<content:encoded><![CDATA[Son 2 yıl içerisinde Mikro-blogları ve bu konuda geliştirilen web uygulamalarının adını çokça duyduk. Bu yıl ise, özellikle lokasyon bazlı uygulama örneklerini görmeye başladık. Foursquare, Loopt, Google Latitude, Gowalla, Rummble ve bu işe yeni girişen Twitter, Facebook aklıma gelen ilk örnekleri. (Ben bu yazıyı hazırlarken; Yahoo, FourSquare'ı satın almayı düşünüyor fakat 100 Milyon$ edip etmeyeceğine karar vermeye çalışıyordu)

Lokasyon bazlı servisler gizlilik konusunuda beraberinde getirdi. Hatta bu konuda Google'ın CEO'su Eric Schmidt'in '<a href="http://www.theregister.co.uk/2009/12/07/schmidt_on_privacy/">Gizlenmek istemeniz, gizlenmesi gereken işlerle meşgul olduğunuz anlamına gelir</a>' demecine en güzel cevabı, "Lütfen beni soyun" anlamına gelen ve foursquare'daki bulunduğunuz konuma göre hırsızlara davetiye çıkaran, <a href="http://PleaseRobMe.com">PleaseRobMe.com</a> isimli bir sitenin verdiğini düşünüyorum. Halen gizlilik politikaları lokasyon bazlı servislere karşı önyargıları olan insanları tatmin ettiği söylenemez.

Gizlilik konusu daha çok tartışılacak bir konu gibi görünüyor. Bunun en son örneği ise Fazlamesai.net sitesindeki <a href="http://www.fazlamesai.net/?a=article&amp;sid=5399">"Kim? Ne zaman? Kiminle? Nerede?"</a> başlıklı yazısı.

Bu tartışmalar süre dursun, lokasyon bazlı servisler artık hayatımıza girdi ve çıkacak gibide durmuyor. Peki bu işin teknik altyapısında neler var, gelin bunları inceleyelim ve bu blogun amacına uygun bir davranış sergileyelim.<!--more-->

<strong>Lokasyon Bazlı Servisler (LBS) Nedir? </strong>
Bir kişinin lokasyon bilgisini almanın birkaç yöntemi vardır. Bunlar;
<ul>
	<li>IP'den Lokasyon bulma (GeoLocation)</li>
	<li>GSM Operatorunden (3 Baz Istasyonundan Tahmini Lokasyon Bilgisi)</li>
	<li>GPS telefonlar yoluyla bulma</li>
	<li>HTML5 ile birlikte Lokasyonu browser'a sorma (GeoLocation)</li>
	<li>Fotoğrafın EXIF bilgisinden öğrenme</li>
</ul>
Yukarıdaki yöntemlerin hepsiyle konum bilgisini (longitude ve latitude) elde etmek mümkün.
Bunlardan GPS ve GSM ilgili olan yöntemler, makineden makineye ve operatorden operatore değişiklik gösterebileceği için bu yazının kapsamı dışındadır. GSM ve GPS üzerinden lokasyon çekmek özellikle lokasyonun güvenilirliği gerektiği durumlarda daha etkili olmaktadır. Tabii GSM ve GPS gibi sistemleri simule etmekte mümkün ama şimdilik, küçük bir kesimin yapabileceği bir iş.

<strong>Neler Yapılabilir?</strong>
<ul>
	<li><strong>Takip sistemleri; </strong> Kişi ya da aracın takibi için kullanılabilir.</li>
	<li><strong>En yakın lokasyon;</strong> Bulunduğunuz lokasyonun 10 kilometre çevresindekileri bulmak diyebilirim. (Birazdan bu konuda örnek bir uygulama yazacağız) Aklıma ilk gelen örnekler; eczaneler, lokantalar, tanıdık kimseler, ustalar ve kiralık evler  bulmak. Örnekler ve kullanım şekli hayal gücünüzle sınırlı görüldüğü üzere. Bunu bir iPhone yada Android uygulaması ile entregre edildiği düşünülürse tadından yenmez.</li>
	<li><strong>Lokasyona Göre Davranış;</strong>Sitenizin davranışları lokasyona göre değişiklik gösteriyor olabilir. Örneğin, bazı ürünleri sadece bazı lokasyonlar için satıyor olabilirsiniz. Koca bir listeyi müşterinizin karşısına çıkarmak pek anlamsız olabilir. Web 3.0'a hazırlandığımız şu günlerde siteler ne kadar akıllı olursa ve bizden ne kadar az içerik talep ederse o kadar iyi olacaktır.</li>
</ul>
<strong>Nasıl Yapılabilir?</strong>

<strong>IP'den lokasyon bulmak</strong> için, web üzerinde bu hizmeti alabileceğiniz çok fazla firma var. İlk aklıma gelenleri; <a href="http://www.ip2location.com/">IP2Location</a>, <a href="http://www.maxmind.com/">MaxMind</a>, <a href="http://www.geopostcodes.com/">GeoPostcodes</a>.

Bunların içinden ücretsiz bir sürümü bulunan MaxMind firmasının <a href="http://geolite.maxmind.com/">GeoLite</a> isimli ürünü ile ilk demomuzu gerçekleştireceğiz.

<strong>Gereksinimler</strong>
<ul>
	<li><a href="http://php.net">PHP 5</a></li>
	<li><a href="http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz">GeoLiteCity.dat</a></li>
	<li><a href="http://www.maxmind.com/app/php">PHP İçin GeoLocation API Modülü</a></li>
</ul>
Öncelikle ücretsiz şehir verisini indirelim.
<pre lang="bash"># Ornekte kullanilan GeoLiteCity.dat dosyasının kurulumu
su -
mkdir -p /opt/maxmind
cd /opt/maxmind
wget http://geolite.maxmind.com/download/geoip/database/GeoLiteCity.dat.gz
gunzip GeoLiteCity.dat.gz
chmod a+r -R /opt/maxmind

# PHP Modülünün kurulumu.
wget http://geolite.maxmind.com/download/geoip/api/php/geoipregionvars.php
wget http://geolite.maxmind.com/download/geoip/api/php/geoipcity.inc

# Eger Apache ayarlarınızda open_base_dir ayari aktif ise
# PHP kodunuzun bulundugu dizine koyun ve örnekteki yolu degistirin.
</pre>
Şimdi IP'den latitude ve longitude degerlerini bulan kodun demosunu yazalım.

<pre lang="php">
include("geoipcity.inc");
include("geoipregionvars.php");

$gi = geoip_open("/opt/maxmind/GeoLiteCity.dat", GEOIP_STANDARD);
$record = geoip_record_by_addr($gi, $_SERVER["REMOTE_ADDR"]);
geoip_close($gi);

echo "<h1>bulundugunuz sehir</h1><hr/>";
echo "<pre >".print_r($record, true)."</pre >";
</pre>

Bu demonun çalışan haline <a href="http://phparchitect.org/tr/demos/lokasyon-bazli-servisler-yaratmak/geolocation.php" target="demo">şuradan</a> erişebilirsiniz.

<p>
<strong>En yakın şeyi bulmak</strong> ile anlatılmak istenen bilinen bir lokasyonun etrafında bulunan (diyelim ki 1 kmlik) bir alan içerisindeki nesneleri bulmaktan söz edilmektedir. Örneğin bir ilan sitesi için bu kiralık veya satılık evler, araçlar ve çeşitli taşınır ve taşınmazlar olabilir. Ya da, "Ne/Nerede" servisi için, çilingir, taksi durağı ve eczanenin bulunduğu yerler de bulunabilir.

Bu konuda eğer web üzerinde araştırma yapmayı düşünüyorsanız, arama motorlarına "radius search" yazmanız yeterli olacaktır.  Karşınızda, lokasyon üzerine, özellikle <u>posta kodu (zipcode)</u> hizmeti sunan siteler çıkacaktır. Tahmin ettiğiniz üzere anahtar kelime, <strong>posta kodu</strong> bilgisi. Daha doğrusu mahalle seviyesine indirgenmiş longitude ve latitude değerlerine sahip olmak. Bu sayede, yarıçap hesabı <strong>(radius)</strong> yaparak, örneğin 1km'lik bir alana ait mahallelere erişemek mümkün. İşte işin büyüsü burada. <a href="http://yelp.com">Yelp</a> ve <a href="http://foursquare.com">FourSquare</a> bu şekilde size mekan bilgilerini verir.
</p>
<p>
Bu hesaplamanın nasıl yapıldığını araştırırken, <a href="http://codeguru.com">CodeGuru</a> sitesinde <a href="http://www.codeguru.com/Cpp/Cpp/algorithms/article.php/c5115/">Coğrafik Bölge Hesaplamaları</a> başlıklı bir makaleye rastladım. Kodlar C++ diliyle yazılmıştı. Bu işin mantığıyla ilgilenen <a href="http://www.fazlamesai.net/index.php?a=article&sid=3102">olay odaklı programcılar</a> için güzel bir makale. Ama yok hani PHP ile yazılmış kodları merak eden <a href="http://www.fazlamesai.net/index.php?a=article&sid=3102">ürün odaklı</a> programcı kardeşlerim için ise, Steven Brendtro tarafından PHP diline port edilen GeoCalc sınıfını ve <a href="http://imaginerc.com/software/GeoCalc/">şuradaki</a> makalesini tavsiye ederim.
</p>
<p>
Peki yarıçap hesabı yapmak için gerekli PHP kütüphanemizde var artık. Aşağıda anlatacağım örnek için, posta kodu veritabanı tablonuz olduğu varsayılmıştır. Yani şimdi bulmamız gereken, posta kodları seviyesinde latitude ve longitude değerleri. Bu konuda ücretli olmasına rağmen şiddetle tavsiye edebileceğim site  <a href="http://www.geopostcodes.com/index.php?pg=browse&grp=1&sort=1&niv=3&id=489&l=0">GeoPostcodes</a>. Gerçekten çok iyi bir içeriğe sahip. Diğer bir alternatif için ise, arama motorundan bulduğum ve hiç deneme fırsatı bulamadığım <a href="http://www.zip-codes.com/">ZipCodes</a> isimli site. Son olarak posta kodları ile ilgili ücretsiz siteler bulmanız mümkün ama bunların çoğu Amerika için geçerli :(
</p>

Peki şimdi gelin GeoCalc ile 1 km'lik bir alan nasıl bulduğumuzu inceleyelim.
<pre lang="php">
include_once("GeoCalc.class.php");
$oGC = new GeoCalc();

// IP'den lokasyon bulma yoluyla bulduğumuz değerler. 
$dLongitude = -94.44590241;
$dLatitude = 38.7996;

// Ne kadarlık bir alanda sorgulama yapılacak?!
$dRadius = 1.00;  // in kilometers

// Yarıçap Hesabı.
$dAddLat = $oGC->getLatPerKm() * $dRadius;
$dAddLon = $oGC->getLonPerKmAtLat($dLatitude) * $dRadius;

// Sınırların belirlenmesi.
$dNorthBounds = $dLatitude + $dAddLat;
$dSouthBounds = $dLatitude - $dAddLat;
$dWestBounds = $dLongitude - $dAddLon;
$dEastBounds = $dLongitude + $dAddLon;

print "Merkezi Longitude: $dLongitude\n";
print "Merkezi Latitude: $dLatitude\n";
print "Yarıçap: $dRadius kilometre\n";

print "Kuzey Sınırı: $dNorthBounds\n";
print "Güney Sınırı: $dSouthBounds\n";
print "Doğu Sınırı: $dEastBounds\n";
print "Batı Sınırı: $dWestBounds\n";

// Örnek sql sorgusu ile hangi bölgeleri kapsadığı bulunur.
$strQuery = "SELECT * FROM PostalCodes " .
              "WHERE Latitude > $dSouthBounds " .
              "AND Latitude < $dNorthBounds " .
              "AND Longitude > $dWestBounds " .
              "AND Longitude < $dEastBounds";

</pre>

Bulunan bu bölge kodlarına bağlı kayıtların çekilmesi ve sayfada listelenmesiyle işlem tamamlanmış olur.

Bu örnekte kullanılan kodların Steven Brendtro'nun sitesinden kaldırılması ihtimaline karşılık <a href="http://phparchitect.org/tr/demos/lokasyon-bazli-servisler-yaratmak/geocalc/geocalc-php-1.2.tar_.gz">şuradan</a> kopyasına erişebilirsiniz.

<p>
Son olarak, <strong>HTML5</strong> ile birlikte gelen lokasyon öğrenme yönteminden söz ederek yazımı sonlandırmak istiyorum. Bu yöntemin, IP'den lokasyon bulmaktan farkı web tarayıcınızdan izin ister ama bunun karşılığında tarayıcının makinede varsa GPS'ten ya da çeşitli servislerden öğreneceği kaliteli bir latitude ve longitude değeri sunar.
</p>
<pre lang="javascript">
if (navigator.geolocation) {   
    navigator.geolocation.getCurrentPosition(function(position) {
        result = "latitude:"+position.coords.latitude+"-";
        result += "longitude:"+position.coords.longitude;
        alert(result); 
    });   
} else {
    alert("Uzgunum, tarayicinizin cografik konum destegi henuz yok! HTML5 destegi olan bir tarayici kullanin.");
}
</pre>

Ayrıca Google Maps ile entegre olarak bölge bilgisine ulaşabileceğiniz <a href="http://phparchitect.org/tr/demos/lokasyon-bazli-servisler-yaratmak/with_html5.php" target="demo">DEMO'ya şuradan</a> erişebilirsiniz.
]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>113</wp:post_id>
		<wp:post_date>2010-04-10 18:35:07</wp:post_date>
		<wp:post_date_gmt>2010-04-10 18:35:07</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>lokasyon-bazli-servisler-yaratmak</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
								<wp:postmeta>
		<wp:meta_key>_edit_lock</wp:meta_key>
		<wp:meta_value><![CDATA[1270924616]]></wp:meta_value>
		</wp:postmeta>
				<wp:postmeta>
		<wp:meta_key>_edit_last</wp:meta_key>
		<wp:meta_value><![CDATA[2]]></wp:meta_value>
		</wp:postmeta>
							</item>
	</channel>
</rss>
